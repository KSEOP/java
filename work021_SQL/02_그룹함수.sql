-- 그룹함수
/*
COUNT, SUM, AVG, MAX, MIN

SUM, AVG
-> 숫자데이터만 가능. (날짜, 문자 등 적용 안됨.)
COUNT, MAX, MIN
*/

-- COUNT()
-- 전체 사원 수를 조회
SELECT COUNT(*)FROM EMP;
SELECT COUNT(EMPNO) FROM EMP; -- NOT NULL이 전제된 기본키 컬럼을 넣을 시 (*)와 수량이 갖다.
SELECT COUNT(-1) 전체사원수 FROM EMP; -- ROW의 끝으로가서 인덱스를 가져옴.

SELECT ROUND(AVG(SAL)), SUM(SAL), MIN(SAL) FROM EMP;

-- 입사한지 가장 오래된 사원의 입사일과, 가장 최근 입사한 사원의 입사일을 검색
SELECT MIN(HIREDATE), MAX(HIREDATE) FROM EMP;

-- 부서 번호가 10번이거나 20번 부서의 사원 수를 검색
SELECT COUNT(EMPNO) -- *, -1 등을 쓸 수 있다.
FROM EMP
WHERE DEPTNO IN (10,20);

-- EMP 테이블에서 부서번호 수를 검색
SELECT COUNT(DISTINCT(DEPTNO)) FROM EMP;

-- 모든 사원의 보너스의 평균
SELECT AVG(COMM) FROM EMP;

-- STEP2
SELECT ROUND(AVG(NVL(COMM, 0))) AS "보너스평균" FROM EMP;

--///////////////////////////////////////////////////

-- 사원의 급여의 평균값을 검색
-- STEP 1
-- 그룹함수에 포함되지 않은 컬럼이 SELECT절에 나열될 수 없다.
-- GROUP BY절 디에 명시되어져야 한다.
SELECT DEPTNO, AVG(SAL) FROM EMP;

-- STEP 2
-- 부서별 평균 급여
SELECT DEPTNO, ROUND(AVG(SAL)) "AvgSalary"
FROM EMP
GROUP BY DEPTNO;
ORDER BY 2;

-- STEP 4 -- GROUPBY에서 ALIAS 인식 불가
SELECT DEPTO, ROUND(AVG(SAL)) "AvgSalary"
FROM EMP
GROUP BY 'AvgSalary'
ORDER BY 2;

-- STEP 5
-- 부서별 급여의 평균을 검색, 10번 부서는 제외하고 검색, 정렬은 부서번호,
-- DEPTNO -> DNUMBER, ROUND(AVG(SAL)) -> AVGSAL,
-- 1.FROM -> 2.WHERE -> 3.GROUP BY -> 4.SELECT -> 5.ORDER BY
SELECT DEPTNO DNUMBER, ROUND(AVG(SAL)) AVGSAL FROM EMP
WHERE DEPTNO !=10
GROUP BY DEPTNO
ORDER BY 2;


SELECT  EXTRACT(YEAR FROM hiredate) as YEAR FROM emp;
SELECT  EXTRACT(MONTH FROM hiredate) as MONTH FROM emp;
SELECT  EXTRACT(DAY FROM hiredate) as DAY FROM emp;

-- STEP1
SELECT EXTRACT(YEAR FROM HIREDATE) AS 입사년도, COUNT(*) 인원수
FROM EMP
GROUP BY EXTRACT(YEAR FROM HIREDATE);


-- STEP2
SELECT TO_CHAR(HIREDATE, 'YY') FROM EMP;

SELECT TO_CHAR(HIREDATE, 'YY') 년도별, COUNT(EMPNO) 사원수
FROM EMP
GROUP BY TO_CHAR(HIREDATE,'YY')
ORDER BY 1;


-- ////////////////
-- STEP 1
-- ERROR
SELECT DEPTNO, ROUND(AVG(SAL))
FROM EMP
WHERE ROUND(AVG(SAL)) >= 2000 -- WHERE 절에 그룹함수 사용 못함. WHERE이 먼저돌기 때문에 그러함.
GROUP BY DEPTNO;
-- WHERE 절에 ALIAS 못씀 !!!!

--STEP 2.
SELECT DEPTNO, ROUND(AVG(SAL))
FROM EMP
HAVING ROUND(AVG(SAL)) >= 2000 -- HAVING은 GROUPING을 한 다음 추려서 DISPLAY함.
GROUP BY DEPTNO;

--STEP 3. 미완성.
SELECT DEPTNOM ROUND(AVG(SAL))
FROM EMP;


-- 최대 급여가 2900가 넘는 부서들의 최대 급여를 출력
-- 그룹함수 조건은 무조건 HAVING 절에 들어감.
-- 1) 부서별 최대 급여... 5000, 3000, 2850,...
-- 2) 5000, 3000
SELECT DEPTNO, MAX(SAL)
FROM EMP
GROUP BY DEPTNO
HAVING MAX(SAL)>2900;

--ROLLUP 1
SELECT DEPTNO, JOB,COUNT(*), SUM(SAL)
FROM EMP
GROUP BY ROLLUP(DEPTNO,JOB);

--ROLLUP 2
SELECT DEPTNO, JOB, SUM(SAL)
FROM EMP
GROUP BY ROLLUP(JOB, DEPTNO);


--GROUPING SET
--예제 1
SELECT DEPTNO, JOB, SUM(SAL)
FROM EMP
GROUP BY GROUPING SETS(DEPTNO, JOB);

SELECT DEPTNO, JOB, SUM(SAL)
FROM EMP
GROUP BY ROLLUP(DEPTNO, JOB);

-- ROLLUP은 부서별로 나누고, 그 안에서 또 JOB별로 나눔. (나눈것에서 또 나눔)
-- 즉 계층 구조를 이룸. 그래서 인자 순서가 영향이 있는 것.
-- GROUPING SETS은 이중 나눔이 아닌, 각각 나눈 것을 합친 것.

-- GROUPING SETS
-- STEP 1.
SELECT deptno, job, SUM(sal)
FROM emp
GROUP BY GROUPING SETS(job, deptno)
ORDER BY JOB,DEPTNO ;

-- STEP 2. UNION ALL
SELECT DEPTNO, SUM(SAL)
FROM EMP
GROUP BY DEPTNO
UNION ALL -- 집합 연산자 위 아래 데이터를 합침 (그루핑셋처럼됨)
SELECT JOB, SUM(SAL)
FROM EMP
GROUP BY JOB;
-- DATATYPE ERROR

-- STEP 3. 숫자를 문자로 바꿔주기
SELECT TO_CHAR(DEPTNO), SUM(SAL)
FROM EMP
GROUP BY DEPTNO
UNION ALL -- 집합 연산자 위 아래 데이터를 합침 (그루핑셋처럼됨)
SELECT JOB, SUM(SAL)
FROM EMP
GROUP BY JOB;

-- STEP 4.
SELECT DEPTNO ||'', SUM(SAL) -- 이렇게하면 가장 좋은 방법임.
FROM EMP
GROUP BY DEPTNO
UNION ALL
SELECT JOB, SUM(SAL)
FROM EMP
GROUP BY JOB;

-- STEP5.

SELECT DEPTNO, NULL JOB, SUM(SAL) -- 책내용. 형변환 어려우면, NULL을 이용해서 공간생성.
FROM EMP
GROUP BY DEPTNO
UNION ALL 
SELECT NULL DEPTNO, JOB, SUM(SAL)
FROM EMP
GROUP BY JOB;

/*
통계쿼리 작성 시 동일한 쿼리문을 GROUP BY절에 작성하고
변경되는 부분들을 일일이 작성한 후 UNION ALL로 결합하는 방식과 (STEP 3 4 5)

GROUPING SETS를 사용하는 방식이 있는데 (STEP 1)

GROUPING SETS를 사용한 방식이 훨씬 속도가 빠르다.

*/








